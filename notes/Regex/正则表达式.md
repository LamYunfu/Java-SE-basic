# 正则表达式

为什么要使用正则表达式？

**文本的复杂处理**

* 正则表达式定义了字符串的模式。

* 正则表达式可以用来搜索、编辑或处理文本。

* 正则表达式并不仅限于某一种语言，但是在每种语言中有细微的差别。

### 标准字符集合

| \d   | 数字字符匹配。等效于 [0-9]。    |
| ---- | ------------------------------- |
| \D   | 非数字字符匹配。等效于 [^0-9]。 |

| \w   | 匹配任何字类字符，包括下划线。与"[A-Za-z0-9_]"等效。 |
| ---- | ---------------------------------------------------- |
| \W   | 与任何非单词字符匹配。与"[^A-Za-z0-9_]"等效。        |

| \s   | 匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。 |
| ---- | ------------------------------------------------------------ |
| \S   | 匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效。                 |

| .    | 匹配除"\r\n"之外的任何单个字符。若要匹配包括"\r\n"在内的任意字符，请使用诸如"[\s\S]"之类的模式。 |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

### 自定义字符集合

| [xyz]    | 字符集。匹配包含的任一字符。例如，"[abc]"匹配"plain"中的"a"。 |
| -------- | ------------------------------------------------------------ |
| [^*xyz*] | 反向字符集。匹配未包含的任何字符。例如，"[^abc]"匹配"plain"中"p"，"l"，"i"，"n"。 |
| [*a-z*]  | 字符范围。匹配指定范围内的任何字符。例如，"[a-z]"匹配"a"到"z"范围内的任何小写字母。 |
| [^*a-z*] | 反向范围字符。匹配不在指定的范围内的任何字符。例如，"[^a-z]"匹配任何不在"a"到"z"范围内的任何字 |

### 量词（Quantifier）

| {*n*}     | *n* 是非负整数。正好匹配 *n* 次。例如，"o{2}"与"Bob"中的"o"不匹配，但与"food"中的两个"o"匹配。 |
| --------- | ------------------------------------------------------------ |
| {*n*,}    | *n* 是非负整数。至少匹配 *n* 次。例如，"o{2,}"不匹配"Bob"中的"o"，而匹配"foooood"中的所有 o。"o{1,}"等效于"o+"。"o{0,}"等效于"o*"。 |
| {*n*,*m*} | *m* 和 *n* 是非负整数，其中 *n* <= *m*。匹配至少 *n* 次，至多 *m* 次。例如，"o{1,3}"匹配"fooooood"中的头三个 o。'o{0,1}' 等效于 'o?'。注意：您不能将空格插入逗号和数字之间。(贪婪模式加!(默认)， 非贪婪模式加？) |
| *         | 零次或多次匹配前面的字符或子表达式。例如，zo* 匹配"z"和"zoo"。* 等效于 {0,}。 |
| +         | 一次或多次匹配前面的字符或子表达式。例如，"zo+"与"zo"和"zoo"匹配，但与"z"不匹配。+ 等效于 {1,}。 |
| ?         | 零次或一次匹配前面的字符或子表达式。例如，"do(es)?"匹配"do"或"does"中的"do"。? 等效于 {0,1}。 |

### 字符边界

本组标记匹配的不是字符，而是位置，也就是匹配符合某种条件的位置。

| ^    | 匹配输入字符串开始的位置。如果设置了 **RegExp** 对象的 **Multiline** 属性，^ 还会与"\n"或"\r"之后的位置匹配。 ^i    匹配以i开头的字符串。 |
| ---- | ------------------------------------------------------------ |
| $    | 匹配输入字符串结尾的位置。如果设置了 **RegExp** 对象的 **Multiline** 属性，$ 还会与"\n"或"\r"之前的位置匹配。 |
| \b   | 匹配一个字边界，即字与空格间的位置。例如，"er\b"匹配"never"中的"er"，但不匹配"verb"中的"er"。也就是前面的字符和后面的字符不全是\w |

### 选择符和分组

| 表达式                  | 作用                                                         |
| ----------------------- | ------------------------------------------------------------ |
| \| 分支结构             | 左右两边表达式之间“或关系”匹配左边                           |
| ()  捕获组              | 把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。例如，正则表达式 (dog) 创建了单一分组，组里包含"d"，"o"，和"g"。同时还会对括号里面的内容进行捕获，此时会自动将捕获的内容保存到内存中,并且可以通过反向引用引用到所捕获的内容。 |
| (?:Expression) 非捕获组 | y一些表达式中，不得不使用（），但是又不需要保存（）中子表达式匹配的内容，这个时候可以使用非捕获组来抵消使用（）带来的副作用。匹配 *pattern* 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。也就是利用了括号可以组织内容的功能，但是又避免了捕获会将捕获内容进行存储的特性带来的内存消耗。 |

**反向引用（\nnn）**

* 每一对（）会分配一个编号，使用（）的捕获根据左括号的顺序从1开始自动编号。
* 通过反向引用，可以对分组已捕获的字符串进行引用。利用\n来引用第n个括号捕获的内容。

### 预搜索（零宽断言、环视）

* 只进行子表达式的匹配，匹配内容不计入最终的匹配结果，是零宽度。
* 这个位置应该符合某个条件。判断当前位置的前后字符，是否符合指定条件，但是不匹配前后的字符。是对位置的匹配。
* 正则表达式匹配过程中，如果子表达式匹配到的是字符内容，而非位置，并被保存到最终的匹配结果中，那么就认为这个子表达式是占有字符的；如果子表达式匹配的仅仅是位置，或者匹配的内容并不保存到最终的匹配结果中，那么就认为这个子表达式是**零宽度**的。占有字符还是零宽度，是针对匹配的内容是否保存到最终匹配结果而言的。

| (?=exp)  | 断言自身出现的位置后面能匹配表达式exp |
| -------- | ------------------------------------- |
| (?<=exp) | 断言自身出现的位置前面能匹配表达式exp |
| (?!exp)  | 断言此位置后面不能匹配表达式exp       |
| (?<exp)  | 断言此位置前面不能匹配表达式exp       |

